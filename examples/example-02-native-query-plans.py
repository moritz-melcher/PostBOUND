#!/usr/bin/env python3
#
# This script shows how to retrieve query plans that are generated by the native optimizer of an actual database system
#
# Requirements: a running IMDB instance on Postgres with the connect file being set-up correctly. This can be achieved using
# the utilities from db-support/postgres.
#

import postbound as pb
from postbound.optimizer.strategies import native

# Setup: we optimize queries from the Join Order Benchmark on a Postgres database
postgres_db = pb.postgres.connect()
job_workload = pb.workloads.job()

# Since obtaining native execution plans is a pretty common use-case, there already is a pre-defined strategy to do this.
# Take a look at the native module for other strategies.
# If we were to use a different database in our NativeOptimizer than in our pipeline, we would optimize queries using that
# database, but execute them on a different system (e.g. calling NativeOptimizer(db_a) but creating OptimizationPipeline(db_b))
predef_pipeline = (
    pb.IntegratedOptimizationPipeline(postgres_db)
    .setup_optimization_algorithm(native.NativeOptimizer(postgres_db))
    .build()
)


# Nevertheless, native optimization (or parts of it) can still be implemented using only a couple lines of code:
class OurNativeOptimizer(pb.CompleteOptimizationAlgorithm):
    def __init__(self, native_optimizer: pb.db.OptimizerInterface) -> None:
        super().__init__()
        self.native_optimizer = native_optimizer

    def optimize_query(self, query: pb.qal.SqlQuery) -> pb.QueryPlan:
        # Obtain the native query exection plan
        native_plan = self.native_optimizer.query_plan(query)
        return native_plan

    def describe(self) -> dict:
        return {"name": "native_plans"}


custom_pipeline = (
    pb.IntegratedOptimizationPipeline(postgres_db)
    .setup_optimization_algorithm(OurNativeOptimizer(postgres_db))
    .build()
)

# We can use both pipelines exactly as exepected and they should also provide the same results (except if the native optimizer
# changes its mind between two optimizations of the same query)
query = job_workload["1a"]

print("Pre-defined strategy:")
predef_optimization = predef_pipeline.optimize_query(query)
print(pb.qal.format_quick(predef_optimization))
print("--- --- ---")

print("Custom strategy:")
custom_optimization = custom_pipeline.optimize_query(query)
print(pb.qal.format_quick(custom_optimization))
print("--- --- ---")
